C51 COMPILER V9.54   NEWCAN                                                                06/24/2021 10:48:03 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE NEWCAN
OBJECT MODULE PLACED IN .\Objects\newCAN.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE newCAN.c COMPACT OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\newCAN.lst) TABS(2) OBJECT(.\Objects\newCAN.obj)

line level    source

   1          #include <reg51.h>
   2          #include "MCP2515.H"
   3          #include <intrins.h>
   4          sbit SCK=P1^7;
   5          sbit MOSI=P1^5; 
   6          sbit MISO=P1^6;
   7          sbit CS=P1^4;
   8          #define CAN_10Kbps  0x31
   9          #define CAN_25Kbps  0x13
  10          #define CAN_50Kbps  0x09
  11          #define CAN_100Kbps 0x04
  12          #define CAN_125Kbps 0x03
  13          #define CAN_250Kbps 0x01
  14          #define CAN_500Kbps 0x00
  15          #define UART1_Rx_Buff_LEN 100 //UART Receive Databuffer len
  16          bit busy = 1; //UART µo°e¼Æ¾Úª¬ºA
  17          unsigned char UART1_RX_Buffer[UART1_Rx_Buff_LEN]; //«Ø¥ß±µ¦¬°}¦C ¤j¤p¬°100
  18          unsigned char Uart1_Delay = 0 ; //©µ¿ð®É¶¡¡Aª½¨ì¼Æ¾Ú±µ¦¬§¹¦¨
  19          unsigned char Uart1_Write_Count = 0; //UART¼g¤JBuffer Pointer
  20          unsigned char Uart1_Read_Count = 0; //UARTÅª¨úBuffer Pointer
  21          unsigned char Uart1_Finish = 0; //±µ¦¬§¹·í«e¼Æ¾ÚºX¼Ð
  22          unsigned char CAN_Flag = 0; //CAN±µ¦¬¨ì¼Æ¾ÚºX¼Ð
  23          unsigned char CAN_RX_Buffer[8]; //CAN±µ¦¬¼Æ¾Ú«O¦s°}¦C ¤j¤p¬°8byte
  24          
  25          void Delay_Nms(unsigned int x)
  26          {
  27   1        unsigned int y;
  28   1      
  29   1        for (;x>0;x--)
  30   1          for (y=0;y<100;y++);
  31   1      }
  32          
  33          unsigned char SPI_ReadByte(void)  //³z¹LSPIÅª¨ú¤@­ÓByteªº¸ê®Æ,rBtye¬°ªð¦^­È(Åª¨ìªº¤@­ÓDataByte)
  34          {
  35   1        unsigned char i,rByte=0;
  36   1        
  37   1        SCK=0;
  38   1        for(i=0;i<8;i++)
  39   1        {
  40   2          SCK=1;
  41   2          rByte<<=1;
  42   2          rByte|=MISO;
  43   2          SCK=0;  
  44   2        }
  45   1        return rByte;
  46   1      }
  47          
  48          void SPI_SendByte(unsigned char dt)  //³z¹LSPIµo°e¤@­ÓByteªº¸ê®Æ dt¬°µ¥«Ýµo°eªº¼Æ¾Ú
  49          {
  50   1        unsigned char i;
  51   1          
  52   1        for(i=0;i<8;i++)
  53   1        { 
  54   2          SCK=0;
C51 COMPILER V9.54   NEWCAN                                                                06/24/2021 10:48:03 PAGE 2   

  55   2          if((dt<<i)&0x80)
  56   2            MOSI=1;
  57   2          else
  58   2            MOSI=0;         
  59   2          SCK=1;
  60   2        }
  61   1        SCK=0;
  62   1      }
  63          
  64          
  65          //³z¹LSPI¦VMCP2515«ü©wªº¦a§}¼g¤@­Óbyteªº¸ê®Æ¡A dat¬°·Ç³Æ¼g¤Jªº¸ê®Æ
  66          void MCP2515_WriteByte(unsigned char addr,unsigned char dat)
  67          {
  68   1        CS=0;       
  69   1        SPI_SendByte(CAN_WRITE);  //µo°e¼g©R¥O
  70   1        SPI_SendByte(addr);     //µo°e¦a§}
  71   1        SPI_SendByte(dat);      //¼g¤J¼Æ¾Ú
  72   1        CS=1;       
  73   1      }
  74          
  75          
  76          unsigned char MCP2515_ReadByte(unsigned char addr) //³z¹LSPI±qMCP2515«ü©wªº¦a§} Åª¤@­ÓByteªº¸ê®Æ
  77          {
  78   1        unsigned char rByte;
  79   1        
  80   1        CS=0;   
  81   1        SPI_SendByte(CAN_READ);   //µo°eÅª©R¥O
  82   1        SPI_SendByte(addr);     //µo°e¦a§}
  83   1        rByte=SPI_ReadByte();   //Åª¨ú¼Æ¾Ú
  84   1        CS=1;       
  85   1        return rByte;       //ªð¦^Åª¨ìªº¤@­Ó¦r¸`¼Æ¾Ú
  86   1      }
  87          
  88          //µo°ereset«ü¥O ³z¹L³nÅéreset MCP2515¡A±NMCP2515³]¬°°t¸m¼Ò¦¡
  89          void MCP2515_Reset(void)
  90          {
  91   1        CS=0;       
  92   1        SPI_SendByte(CAN_RESET);  //µo°eReset©R¥O
  93   1        CS=1;       
  94   1      }
  95          
  96          
  97          //MCP2515ªì©l¤Æ--Reset/Àj²v³]©w/¼È¦s¾¹³]©w
  98          void MCP2515_Init(void)
  99          {
 100   1        unsigned char temp=0;
 101   1      
 102   1        MCP2515_Reset();  
 103   1        Delay_Nms(1);   
 104   1        
 105   1        //³]¸mªi¯S²v¬°125Kbps
 106   1        //set CNF1,SJW=00,ªø«×¬°1TQ,BRP=49,TQ=[2*(BRP+1)]/Fsoc=2*50/8M=12.5us
 107   1        MCP2515_WriteByte(CNF1,CAN_125Kbps);
 108   1        //set CNF2,SAM=0,¦b±Ä¼ËÂI¹ïÁ`½u¶i¦æ¤@¦¸±Ä¼Ë¡APHSEG1=(2+1)TQ=3TQ,PRSEG=(0+1)TQ=1TQ
 109   1        MCP2515_WriteByte(CNF2,0x80|PHSEG1_3TQ|PRSEG_1TQ);
 110   1        //set CNF3,PHSEG2=(2+1)TQ=3TQ,¦P®É·íCANCTRL.CLKEN=1®É³]©wCLKOUT¤Þ¸}¬°®É¶¡¿é¥X¨Ï¯à¦ì
 111   1        MCP2515_WriteByte(CNF3,PHSEG2_3TQ);
 112   1        
 113   1        MCP2515_WriteByte(TXB0SIDH,0xFF);//µo°e½w½Ä¾¹0¼Ð·Ç¼ÐÃÑ²Å°ª¦ì
 114   1        MCP2515_WriteByte(TXB0SIDL,0xEB);//µo°e½w½Ä¾¹0¼Ð·Ç¼ÐÃÑ²Å§C¦ì(²Ä3¦ì¬°µo°e©Ý®i¼ÐÃÑ²Å¨Ï¯à¦ì)
 115   1        MCP2515_WriteByte(TXB0EID8,0xFF);//µo°e½w½Ä¾¹0©Ý®i¼ÐÃÑ²Å°ª¦ì
 116   1        MCP2515_WriteByte(TXB0EID0,0xFF);//µo°e½w½Ä¾¹0©Ý®i¼ÐÃÑ²Å§C¦ì
C51 COMPILER V9.54   NEWCAN                                                                06/24/2021 10:48:03 PAGE 3   

 117   1        
 118   1        MCP2515_WriteByte(RXB0SIDH,0x00);//²MªÅ±µ¦¬½w½Ä¾¹0ªº¼Ð·Ç¼ÐÃÑ²Å°ª¦ì
 119   1        MCP2515_WriteByte(RXB0SIDL,0x00);//²MªÅ±µ¦¬½w½Ä¾¹0ªº¼Ð·Ç¼ÐÃÑ²Å§C¦ì
 120   1        MCP2515_WriteByte(RXB0EID8,0x00);//²MªÅ±µ¦¬½w½Ä¾¹0ªº©Ý®i¼ÐÃÑ²Å°ª¦ì
 121   1        MCP2515_WriteByte(RXB0EID0,0x00);//²MªÅ±µ¦¬½w½Ä¾¹0ªº©Ý®i¼ÐÃÑ²Å§C¦ì
 122   1        MCP2515_WriteByte(RXB0CTRL,0x40);//¶È¶È±µ¦¬©Ý®i¼ÐÃÑ²Åªº¦³®Ä«H®§
 123   1        MCP2515_WriteByte(RXB0DLC,DLC_8);//³]¸m±µ¦¬¼Æ¾Úªºªø«×¬°8­Ó¦r¸`
 124   1        
 125   1        MCP2515_WriteByte(RXF0SIDH,0xFF);//°t¸mÅç¦¬Âoªi±H¦s¾¹n¼Ð·Ç¼ÐÃÑ²Å°ª¦ì
 126   1        MCP2515_WriteByte(RXF0SIDL,0xEB);//°t¸mÅç¦¬Âoªi±H¦s¾¹n¼Ð·Ç¼ÐÃÑ²Å§C¦ì(²Ä3¦ì¬°±µ¦¬©Ý®i¼ÐÃÑ²Å¨Ï¯à¦ì)
 127   1        MCP2515_WriteByte(RXF0EID8,0xFF);//°t¸mÅç¦¬Âoªi±H¦s¾¹n©Ý®i¼ÐÃÑ²Å°ª¦ì
 128   1        MCP2515_WriteByte(RXF0EID0,0xFF);//°t¸mÅç¦¬Âoªi±H¦s¾¹n©Ý®i¼ÐÃÑ²Å§C¦ì
 129   1      
 130   1        MCP2515_WriteByte(RXM0SIDH,0x00);//°t¸mÅç¦¬«Ì½ª±H¦s¾¹n¼Ð·Ç¼ÐÃÑ²Å°ª¦ì
 131   1        MCP2515_WriteByte(RXM0SIDL,0x00);//°t¸mÅç¦¬«Ì½ª±H¦s¾¹n¼Ð·Ç¼ÐÃÑ²Å§C¦ì
 132   1        MCP2515_WriteByte(RXM0EID8,0x00);//°t¸mÅç¦¬Âoªi±H¦s¾¹n©Ý®i¼ÐÃÑ²Å°ª¦ì
 133   1        MCP2515_WriteByte(RXM0EID0,0x00);//°t¸mÅç¦¬Âoªi±H¦s¾¹n©Ý®i¼ÐÃÑ²Å§C¦ì
 134   1        
 135   1        MCP2515_WriteByte(CANINTF,0x00);//²MªÅCAN¤¤Â_¼Ð»x±H¦s¾¹ªº©Ò¦³¦ì(¥²¶·¥ÑMCU²MªÅ)
 136   1        MCP2515_WriteByte(CANINTE,0x01);//°t¸mCAN¤¤Â_¨Ï¯à±H¦s¾¹ªº±µ¦¬½w½Ä¾¹0º¡¤¤Â_¨Ï¯à,¨ä¥¦¦ì¸T¤î¤¤Â_
 137   1        
 138   1        MCP2515_WriteByte(CANCTRL,REQOP_NORMAL|CLKOUT_ENABLED);//±NMCP2515³]¸m¬°¥¿±`¼Ò¦¡,°h¥X°t¸m¼Ò¦¡
 139   1        
 140   1        temp=MCP2515_ReadByte(CANSTAT);//Åª¨úCANª¬ºA±H¦s¾¹ªº­È
 141   1        if(OPMODE_NORMAL!=(temp&&0xE0))//§PÂ_MCP2515¬O§_¤w¸g¶i¤J¥¿±`¼Ò¦¡
 142   1        {
 143   2          MCP2515_WriteByte(CANCTRL,REQOP_NORMAL|CLKOUT_ENABLED);//¦A¦¸±NMCP2515³]¸m¬°¥¿±`¼Ò¦¡,°h¥X°t¸m¼Ò¦¡
 144   2        }
 145   1      }
 146          
 147          
 148          //CANµo°e«ü©wªø«×ªº¸ê®Æ  *CAN_TX_Buf(µ¥«Ýµo°eªºBuffer pointer) len(µ¥«Ýµo°eªº¼Æ¾Úªø«×)
 149          void CAN_Send_Buffer(unsigned char *CAN_TX_Buf,unsigned char len)
 150          {
 151   1        unsigned char j,dly,count;
 152   1      
 153   1        count=0;
 154   1        while(count<len)
 155   1        {
 156   2          dly=0;
 157   2          while((MCP2515_ReadByte(TXB0CTRL)&0x08) && (dly<50))//§Ö³tÅª¬Y¨Çª¬ºA«ü¥O,µ¥«ÝTXREQ¼Ð»x²M¹s page15
 158   2          {
 159   3            Delay_Nms(1);
 160   3            dly++;
 161   3          }
 162   2              
 163   2          for(j=0;j<8;)
 164   2          {
 165   3            MCP2515_WriteByte(TXB0D0+j,CAN_TX_Buf[count++]);//±N«Ýµo°eªº¼Æ¾Ú¼g¤Jµo°e½w½Ä±H¦s¾¹
 166   3            j++;
 167   3            if(count>=len) 
 168   3              break;
 169   3          }
 170   2          MCP2515_WriteByte(TXB0DLC,j);//±N¥»´V«Ýµo°eªº¼Æ¾Úªø«×¼g¤Jµo°e½w½Ä¾¹0ªºµo°eªø«×±H¦s¾¹
 171   2          CS=0;
 172   2          MCP2515_WriteByte(TXB0CTRL,0x08);//½Ð¨Dµo°e³ø¤å
 173   2          CS=1;
 174   2        }
 175   1      }
 176          
 177          //CAN±µ¦¬¸ê®Æ *CAN_RX_Buf µ¥«Ý±µ¦¬ªº½w½Ä°Ï«ü°w,ªð¦^len(±µ¦¬¨ì¼Æ¾Úªºªø«×)
 178          unsigned char CAN_Receive_Buffer(unsigned char *CAN_RX_Buf)
C51 COMPILER V9.54   NEWCAN                                                                06/24/2021 10:48:03 PAGE 4   

 179          {
 180   1        unsigned char i=0,len=0,temp=0;
 181   1      
 182   1        temp = MCP2515_ReadByte(CANINTF); //CANINTF¬°¤¤Â_¼Ð»x¼È¦s¾¹ 
 183   1        if(temp & 0x01)  //if µ²ªG¤£¬°0 , temp = 0x01
 184   1        {
 185   2          len=MCP2515_ReadByte(RXB0DLC);//Åª¨ú±µ¦¬½w½Ä¾¹0±µ¦¬¨ìªº¼Æ¾Úªø«×(0~8­Ó¦r¸`)
 186   2          while(i<len)
 187   2          { 
 188   3            CAN_RX_Buf[i]=MCP2515_ReadByte(RXB0D0+i);//§âCAN±µ¦¬¨ìªº¼Æ¾Ú©ñ¤J«ü©w½w½Ä°Ï
 189   3            i++;
 190   3          }
 191   2        }
 192   1        MCP2515_WriteByte(CANINTF,0);//²M°£¤¤Â_¼Ð»x¦ì(¤¤Â_¼Ð»x±H¦s¾¹¥²¶·¥ÑMCU²M¹s)
 193   1        return len;
 194   1      }
 195          
 196          //Timer0_Init ªì©l¤ÆTimer0
 197          void Timer0_Init(void)
 198          {
 199   1        TMOD=0x21; //Timer0 gate c/t mode1  
 200   1        TH0=(65536-46080)/256;//ªì©l¤Æ­p®É­È
 201   1        TL0=(65536-4608)%256; //0.05S
 202   1        TR0=1; //¶}©l­p®É
 203   1        ET0 = 1; //¶}±ÒTimer0¤¤Â_
 204   1        EA = 1; //¶}©l©Ò¦³¥i­P¯à¤¤Â_  
 205   1      }
 206          
 207          //Timer0_ISR ,ÀË¬dUART¬O§_±µ¦¬¼Æ¾Ú§¹¦¨
 208          void Timer0_ISR(void) interrupt 1
 209          {
 210   1        if(Uart1_Delay>0)
 211   1        {
 212   2          Uart1_Delay--;
 213   2          if(Uart1_Delay==0)
 214   2          {
 215   3            //©µ®É®É¶¡¨ì¦A¨S¦³±µ¦¬¨ì·sªº¦ê¤f¼Æ¾Ú¡Aªí¥Ü1´V¼Æ¾Ú±µ¦¬§¹¦¨
 216   3            if(Uart1_Write_Count != Uart1_Read_Count) 
 217   3              Uart1_Finish=1;
 218   3          }
 219   2        }
 220   1      
 221   1        TH0=(65536-46080)/256;//ªì©l¤Æ­p®É­È
 222   1        TL0=(65536-4608)%256; //0.05S
 223   1      }
 224          
 225          //¥~³¡¤¤Â_ªì©l¤Æ
 226          void Exint1_Init(void)
 227          {
 228   1          PX1=1;    //³]¸m¥~³¡¤¤Â_1ªº¤¤Â_Àu¥ý¯Å¬°°ªÀu¥ý¯Å
 229   1          IT1 = 1;  //³]¸mINT1ªº¤¤Â_Ãþ«¬ (1:¶È¤U­°ªu 0:¤W¤Éªu©M¤U­°ªu)
 230   1          EX1 = 1;  //¨Ï¯àINT1¤¤Â_
 231   1          EA = 1;   //¨Ï¯àÁ`¤¤Â_
 232   1      }
 233          
 234          //¥~³¡¤¤Â_1ªA°È¨ç¼Æ
 235          void Exint1_ISR(void) interrupt 2
 236          {
 237   1        CAN_Flag=1;//CAN±µ¦¬¨ì¼Æ¾Ú¼Ð»x
 238   1      }
 239          
 240          //UARTªì©l¤Æ³]©w
C51 COMPILER V9.54   NEWCAN                                                                06/24/2021 10:48:03 PAGE 5   

 241          void UART1_Init_Config(void)  
 242          {
 243   1        SCON=0x50; //¦ê¦C¼Ò¦¡1
 244   1        PCON&=0x7F; //SMOD = 0
 245   1        TMOD |= 0x21; //Timer1¼Ò¦¡2
 246   1        TH1=TL1=0xFD; // 9600
 247   1        TR1 = 1; //Timer1±Ò°Ê
 248   1        ES = 1;//UART±Ò°Ê
 249   1        EA = 1; //¶}©l©Ò¦³­P¯à¤¤Â_
 250   1      }
 251          
 252          //UART «ü°w,Åª¼g«ü°w¦U+1  *pnt(«ü¦VUART¤¤Åª»P¼gªº½w½Ä°Ï«ü°w)
 253          void UART1_Buffer_PntAdd(unsigned char *pnt)
 254          {
 255   1        *pnt+=1;
 256   1        if(*pnt >= UART1_Rx_Buff_LEN) 
 257   1          *pnt=0;
 258   1      }
 259          
 260          //UART_ISR 
 261          void UART1_ISR(void) interrupt 4
 262          {
 263   1        unsigned char ch;
 264   1        //±µ¦¬¼Æ¾Ú
 265   1        if(RI)
 266   1        {
 267   2          RI = 0;//²M°£RI¦ì
 268   2          ch=SBUF;
 269   2          UART1_RX_Buffer[Uart1_Write_Count]=ch;  //±N±µ¦¬¨ìªº¼Æ¾Ú¼g¤J½w½Ä°Ï
 270   2          UART1_Buffer_PntAdd(&Uart1_Write_Count);//¼g¦ê¤f1½w½Ä°Ï«ü°w¥[1      
 271   2          if(Uart1_Write_Count == Uart1_Read_Count)//¦pªGÅª¡B¼g½w½Ä°Ï«ü°w­«Å|,«hÅª«ü°w¥[1,³o®É±N¥á¥¢1­Ó¦r¸`¼Æ¾Ú
 272   2          {
 273   3            UART1_Buffer_PntAdd(&Uart1_Read_Count);//Åª¦ê¤f1½w½Ä°Ï«ü°w¥[1
 274   3          }
 275   2          Uart1_Delay = 20;//¦ê¤f1±µ¦¬¼Æ¾Ú´V©µ®É(ms)¡A©µ®É®É¶¡¨ì·í1´V¼Æ¾Ú±µ¦¬§¹¦¨
 276   2        }
 277   1        //µo°e¼Æ¾Ú
 278   1        if (TI)     
 279   1        {
 280   2          TI = 0;   //²M°£TI¦ì
 281   2          busy = 0; //²M¦£¼Ð»x(1¦£,0ªÅ¶¢)
 282   2        }
 283   1      }
 284          
 285          //UARTµo°e¤@­Óbyte,dat=µ¥«Ýµo°eªº¸ê®Æ
 286          void UART1_SendData(unsigned char dat)
 287          {
 288   1          while (busy); //µ¥«Ý«e­±ªº¼Æ¾Úµo°e§¹¦¨
 289   1          busy = 1;   //¦ê¤f1µo°e¼Æ¾Ú¦£¼Ð»x¦ì(1¦£,0ªÅ¶¢)
 290   1          SBUF = dat;   //¼g¼Æ¾Ú¨ìUART¼Æ¾Ú±H¦s¾¹
 291   1      }
 292          
 293          //UART1µo°e¤@­Ó½w½Ä°Ï¼Æ¾Ú,*buff¡G«Ýµo°e½w½Ä°Ï­º¦a§},len¡G«Ýµo°e¼Æ¾Úªø«×
 294          void UART1_SendBuffer(unsigned char *buff,unsigned int len)
 295          {
 296   1        unsigned int i=0;
 297   1      
 298   1        if(len<=0) return;
 299   1      
 300   1        do
 301   1        {
 302   2          UART1_SendData(buff[i++]);//µo°e·í«e¦r²Å
C51 COMPILER V9.54   NEWCAN                                                                06/24/2021 10:48:03 PAGE 6   

 303   2        }
 304   1        while(i<len);
 305   1      }
 306          
 307          //CANµo°eUART±µ¦¬¨ìªº¸ê®Æ(PC->UART->8051->CAN)
 308          void CAN_Send_Dispose(void)
 309          {
 310   1        unsigned char i=0,len=0,write=0,buff[8];
 311   1        
 312   1        write = Uart1_Write_Count;
 313   1        if(Uart1_Write_Count<Uart1_Read_Count) 
 314   1          write+=UART1_Rx_Buff_LEN;
 315   1        
 316   1        if((write-Uart1_Read_Count) >= 8)//¦pªG¦ê¤f1±µ¦¬½w½Ä°Ï¤¤¥¼Åª¼Æ¾Ú¤j©ó8­Ó¦r¸`,«h³q¹LCANÁ`½uµo°e8­Ó¦r¸`¼Æ¾Ú(
             -CANµo°e¤@´V³ø¤å³Ì¤j8­Ó¦r¸`)
 317   1        {     
 318   2          len = 8;              
 319   2        }
 320   1        else if(Uart1_Finish == 1)//¦pªG¦ê¤f1±µ¦¬½w½Ä°Ï¤¤¥¼Åª¼Æ¾Ú¤p©ó8­Ó¦r¸`,¥B¦A¤]¨S±µ¦¬¨ì¦ê¤fªº¼Æ¾Ú,«hCANµo°e³Ñ
             -¾lªº¼Æ¾Ú
 321   1        {
 322   2          len = write-Uart1_Read_Count;
 323   2          Uart1_Finish=0;//·í«e¤@´V¼Æ¾Ú±µ¦¬§¹¦¨¼Ð»x     
 324   2        }
 325   1        else return;//¦pªG¦ê¤f1±µ¦¬½w½Ä°Ï¤¤¥¼Åª¼Æ¾Ú¤p©ó8­Ó¦r¸`,¥BÁÙ¦b±µ¦¬¦ê¤fªº¼Æ¾Ú«hCAN¥ý¤£µo¼Æ¾Ú,µ¥°÷8­Ó¦r¸`¤F¦
             -Aµo
 326   1        
 327   1        for(i=0;i<len;i++)
 328   1        {
 329   2          buff[i] = UART1_RX_Buffer[Uart1_Read_Count];//±N¦ê¤f±µ¦¬½w½Ä°Ïªº¼Æ¾Ú½Æ»s¨ìCANµo°eÁ{®É½w½Ä°Ïbuff
 330   2          UART1_Buffer_PntAdd(&Uart1_Read_Count);//Åª¦ê¤f1½w½Ä°Ï«ü°w¥[1
 331   2        } 
 332   1        CAN_Send_Buffer(buff,len);//CANµo°e«ü©wªø«×ªº¼Æ¾Ú
 333   1      }
 334          
 335          void main()
 336          {
 337   1        Timer0_Init(); 
 338   1        UART1_Init_Config();
 339   1        Exint1_Init();
 340   1        MCP2515_Init();
 341   1        
 342   1        while(1)
 343   1        {
 344   2          if(Uart1_Write_Count != Uart1_Read_Count)//¦pªGÅª«ü°w¤£µ¥¼g«ü°w,«hÃÒ©ú¦ê¤f1±µ¦¬¨ì¼Æ¾Ú
 345   2          {
 346   3            CAN_Send_Dispose();//CANµo°eUART1±µ¦¬¨ìªº¼Æ¾Ú
 347   3          }
 348   2          else if(Uart1_Finish == 1)
 349   2          {
 350   3            Uart1_Finish = 0;
 351   3          }
 352   2      
 353   2          while((CAN_Flag == 1) || ((P3&0x08) == 0))  
 354   2            //P3=INT1=P3^3 00001000&00001000=0x08 00000000&00001000=0,CAN_Flag =1 ©Î P3µL¤¤Â_®É
 355   2          {
 356   3            unsigned char len;
 357   3            CAN_Flag=0;//CAN±µ¦¬¨ì¼Æ¾Ú¼Ð»x
 358   3            len = CAN_Receive_Buffer(CAN_RX_Buffer);
 359   3            
 360   3            if(len != 0)
 361   3              UART1_SendBuffer(CAN_RX_Buffer,len);//UART1µo°e¤@­Ó½w½Ä°Ï¼Æ¾Ú
C51 COMPILER V9.54   NEWCAN                                                                06/24/2021 10:48:03 PAGE 7   

 362   3          }
 363   2        }
 364   1      }
 365          
 366          
 367          
 368          
 369          
 370          
 371          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1043    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =    113      25
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
